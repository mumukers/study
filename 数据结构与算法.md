数据结构与算法

​	1.时间复杂度

​			常数操作数量表达式忽略低次项只保留最高项，忽略最高项的系数
​			按照最差时间复杂度估计
​			评价一个算法的好坏
​				先看时间复杂度，再通过不同数据样本下的实际运行时间，也就是“常数项时间”
​					解释：
​						当时间复杂度不同时，更高项时间复杂度在大量数据样本面前运行时间更长
​						而当时间复杂度相同时，由于不同运算时间不同，只能通过实际运行来评价算法好坏

​	2.对数器
​			用来检验一个优化的方法是否正确
​			写一个复杂度不好但是易于实现的方法，设置一个随机样本产生器，产生 #较大# （如几十万次）次数的随机测试			案例，复制两份，让两个方法跑相同的测试样本，看结果是否一致，如果有一个随机样本不一致，打印样本进			行人工干预，改进方法

​	3.运算符

​		加减乘除
​				略
​	4.位纳算符
​		&		与
​		|		或
​		^		异或
​		注意：这里是位运算符，需要通过二进制运算来得出结果，并不是逻辑运算符里的异或

​		性质
​				性质一
​						0 ^ N = N
​						N ^ N = 0
​				性质二
​						满足交换律和结合律
​				性质三
​							 a ^ b = c   = 》 a ^ c = b
​				利用性质的实例
​					两数交换
​							1.a = a ^ b
​							2.b = a ^ b
​							3.a = a^b
​						解释
​							通过结合律和性质一达到交换两数目的
​							注意：a 和 b值可以相同，但是在内存里必须是两块独立区域，否则会将一个数抹零（可以通过该现										象知道异或也是）
​					实际经典面试题
​						1.一个整型数组中 #一种数# 出现了奇数次，其他数出现偶数次，找出该数
​							解题思路：
​								通过异或的性质一和性质二，将数组中所有数异或起来，出现偶数次的数就会“对对碰”消除，只剩下								出现奇数次的数

​						2.一个整型数组中 #两种数# 出现了奇数次，其他数出现偶数次，找出这两种数
​							解题思路
​								将数组中所有的数异或之后会得到 eor = a^b,由于这是两种数，所以其中二进制某一位一定是 1，a和								b在该位置之上一个是 0，一个是 1. 找到eor中为 1的一位，通过它来区分该数组中该二进制位为 1还								是为 0，将数组分为两组，各包含 a和 b，将其中一组所有元素再异或就可以得到其中一个，将得到								的与eor异或就可以得到另一个
​							注意
​								某一个不为零的数 a 提取出最右侧的 1(如 10010提取成00010)
​								rigntOne = a&(~a + 1)
​		~  取反

6.算法

​	a.简单排序算法：

​		(1)选择排序：
​			 在不为空且长度大于 1的数组中，选定一个长度 i，将a[i]与它前面的数 a[i-1] 进行比较，若a[i]>a[i-1]  进入下一次			 循环，长度加 1；若a[i]<a[i-1] ,进入内循环，让它前面每一个比它大的数都与他作交换，直到前面的数比它小为止

​			时间复杂度
​				O（n^2）

​	b.查找算法：

​		(1)二分法：
​			  在有序的数组中，通过 target与中间位置的值的不断比较一半一半地缩短范围（可以先判断target是否在范围			  内），从而在达到 middle=left=right 并满足题目特定条件时查找成功

​			  经典场景
​				  1.在一个有序数组中查找某个数是否存在
​				  2.在一个有序数组中，查找 >=某个数最左边的位置
​				  3.局部最小值问题
​					  三种情况
​						  边界
​							  左边第一个数比它右边数小，确定为局部最小
​							  右边最后一个数比它左边数小，确定为局部最小
​						  边界不满足
​							  由左到右最左边数据大小成下降趋势，最右边数据大小成上升趋势，所以中间一定下凹，存在局部最小						  （比它左右两边的数都小），判断中间位置的数是否满足，不满足就看它与左边界还是右边界情况相同，						  	将其置为左（右）边界即可完成二分
​				  理解
​					  当某一个#一半#确定拥有所需要的值时，就可以将另一边舍弃

​				  遇到过的巧妙场景
​				  求两个数组的中位数

​	  求中点的算法：
​			  	mid = left +（（right - left）>> 1 ）
​				  	对于普通算法（right+left）/2来说，运算过程中可能会出现溢出的情况造成结果错误