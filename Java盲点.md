# 面向对象三大特性

---

## 封装

​			把抽象出来的数据【属性】和对数据的操作【方法】封装到一起。数据被保护在内部，程序的其他部分只有通过被			授权的操作【方法】才能对数据进行操作。

### 			好处：

​			1.隐藏实现细节
​			2.可以对数据进行验证

## 继承

​			解决代码复用性问题，当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的			属性和方法，其他类不需要再声明这些属性和方法，只需要通过extends声明继承父类即可。

### 		好处：

​				1.代码复用性提高了
​				2.代码扩展性和可维护性提高了

### 		本质：

​				当继承关系确定后，子类对象创建时，建立的是一个查找的关系

### 		细节：

​				1.子类继承了父类所有属性和方法，非私有的属性和方法子类可以直接访问，私有的属性和方法只能通过父类提					供的公有方法访问
​				2.子类没有继承父类构造器，但是必须调用父类构造器，完成父类初始化。
​				3.当创建子类对象时，关键字不管使用哪个子类构造器默认总会调用父类构造器。如果父类中没有提供无参构造					器，则必须要通过**super**关键字指定用父类中哪个构造器。
​				4.可以用**super**关键字显式指定使用父类中哪个构造器。
​				**5**.super在使用时只能放在构造器第一行，super只能在构造器中使用。
​				**6**.super（）和this（）都只能在构造器第一行，所以不能同时存在。
​				**7**.super（）父类构造器的调用不只限于直接父类，可以一直上溯到Object类
​				8.Java只支持单继承。要继承两个，就要串起来。
​				9.不能滥用继承

## 多态

​			方法和对象具有多种形态，是面向对象的第三大特性，是建立在封装和继承的基础上的

### 			多态具体实现：

#### 					方法多态：

​							方法重载和方法重写

#### 					对象多态：

​							1.对象的编译类型和运行类型可以不同，编译类型是在定义时就确定了，不能变化
​							2.对象的运行类型是可以变化的，可以通过getClass（）方法获取查看
​							3.编译类型看等号左边，运行类型看等号右边

### 					Java的动态绑定机制：

​							1.当调用对象方法时，该方法和对象内存地址/运行类型绑定
​							2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用
​								示例：B继承A，A a=new B()，调用a对象中的属性时，是调用A类中的而不是B类中的
​							3.调用普通方法时，使用的是动态单分派：根据new的类型确定对象
​								调用静态方法时，使用的是静态多分派：根据静态类型确定对象



# 包

---

## 注意

​			当引入一个包时，只允许访问该目录下的所有类，而不允许访问子目录下的类（除非单独引入）

​			解释：该子目录下可能**有相同的类名导致冲突**



# main方法语法说明

1.由JVM来调用main方法

2.JVM调用main方法，所以main方法的访问权限必须是public

3.JVM在调用main方法不需要创建对象

4.main方法接收String类的数组为参数，该数组中保存执行java命令时传递给所运行的类的参数

​	示例：java hello 参数一	参数二	参数三

## 特别注意：

main方法依旧遵守static的使用规则

1.可以调用所在类中静态成员和静态方法

2.不能调用非静态成员和方法，只能通过声明类的一个实例对象来使用

## 如何在idea传递参数给args：

正上方锤子旁边- 》点击edit Configurations

# 基本类型的自动装箱和拆箱

---

## 适用位置

​				引用类型和值类型之间

## 装箱

​			把基础类型封装为一个类

### 			具体实现：

​							调用包装器的**valueOf**方法实现。

## 拆箱

​			把类转化为基础类型（把引用类型的对象转化为值类型的对象）

### 			具体实现：

​							调用包装器的**xxValue**方法实现。

## 注意：



​			1.==比较与变量声明方式和值范围有关：
​				包装类和基础类型**用==比较时，包装类型拆箱 *直接比较 值

​				对于Integer来说
​						int a = 值1
​							将值1存在栈中

​						Integer a = 值1调用的是Integer.valueOf()方法
​							当值1在-128~127**之间**时，不会创建Integer对象
​							当值1在-128~127**之外**时，会调用new  Integer（）创建对象

​						Integer a = new Integer(值1)
​							**不管**值1 是否在-128~127范围内，都直接创建Integer对象

​			2.equals先比较类型是否相同，再比较值是否相同
​				包装类 . equals(基础类)
​					先将基础类封装，再比较类型是否相同，最后比较值的大小。

​			

# 控制流程

---

## if语句

### 注意：

​		if（语句A）中是判断语句A的类型是否为 true或 false
​		语句A为赋值语句如：A=……时返回的值如果不是boolean类型的值，就会报错

#### 		示例：

​				if(a=1)//报错
​				if（flag=true）//不会报错，将flag赋值为true后，再执行{ }内的代码块



## for循环的执行顺序

​			for（表达式1；表达式2；表达式3）{
​					循环体；
​			}

​			第一步：循环开始执行一次表达式1（表达式1只在循环开始时执行，剩下的循环都从第二步判断开始）
​			第二步：执行表达式2进行判断
​			第三步：进入循环**执行循环体**
​			第四步：执行表达式3进行迭代

## switch括号内的类型

​			switch（x）：
​				x的类型可以为byte，short，int，char及其包装类，**不能为long，float，double，boolean**

# 方法参数

---

## 如何传递参数？

​			Java中使用创建对象引用的副本来传递参数。

## Java对方法参数能做什么和不能做什么？

​			1.方法不能修改基本数据类型的参数
​			2.方法可以修改对象参数的状态。
​			3.方法不能让对象参数引用一个新对象

# 代码块（初始化块）

## 适用时机

​					作为属性初始化、构造器的延续。当构造器中出现重复语句时，就可以**使用代码块抽象出构造器中重复语句**

## 分类

### 静态代码块：

​					用static修饰，只能调用静态成员（静态方法和静态属性）
​					只在类加载时调用，所以**只执行一次**

### 普通代码块：

​					无修饰，可以调用任意成员
​					在类创建对象实例时调用，所以**每次创建一个对象就执行一次**

 

## { }内可以填入语句：

​					任何逻辑语句：输入、输出、方法调用、判断、循环

## 调用时间：

​					在类加载时（静态代码块），或者创建类的实例对象时（普通代码块）调用

## 创建对象时的调用顺序：

### 一个类中：

#### 规则：

​			1.优先级相同时，按照在类中定义的顺序调用
​			2.优先级：
​							静态属性初始化 = 静态代码块
​							非静态属性初始化 = 普通代码块
​							静态  >  普通
​			3.静态和普通执行完之后，再执行构造器

### 类存在继承关系：

#### 			只看普通：

​			pubilc AAA{
​				public AAA(){
​					1.先调用super（）构造器
​					2.再调用普通代码块和非静态属性初始化
​					3.再调用构造器主体
​				}
​			}

​			所以调用一个子类构造器时，会先进行父类构造器的调用，父类构造器也会满足上面的执行顺序调用本地的
​			super（）构造器、普通代码块、构造器主体等等，直到Object类

### 			包含静态：

​				通过extends关键字先进行父类加载，再进行子类加载，故先进行父类静态，再进行子类静态

​				1.**调用父类静态**代码块和静态属性初始化
​				2.**调用子类静态**代码快和静态属性初始化

---

​				分割线下面和只看普通一致

​				3.**调用父类普通**代码块和非静态属性初始化
​				4.**调用父类构造器**主体
​				5.**调用子类普通**代码块和非静态属性初始化
​				6.**调用子类构造器**主体

# 方法重载与方法重写

---



## 方法重写

### 概念:

​			重写是**子类对父类的<u>*允许访问的方法*</u>的实现过程进行重新编写**, 返回值和形参都不能改变。
​			即外壳不变，核心重写！（必须是父类中有的方法）

### 规则：

​			1.重写的方法的访问权限不能比父类中被重写的方法的访问权限低，也就是private的方法不能被重写
​			2.参数列表，返回值，方法名必须完全相同
​			3.声明为**final**的方法不能被重写。声明为**static**的方法不能被重写，但是能再次声明
​			4.重写的方法能够抛出任何非强制性异常，但不能抛出**新的强制性异常**
​			5.对于不能继承的方法，就不能重写该方法
​			6.笔者总觉得对抽象方法实现是一种特殊的重写

### 运行时：

​			先找到两个类中都有的方法，然后执行时看子类的具体实现

## 方法重载

### 概念：

​			重载是在一个类里面，方法名相同，参数不同，返回值可以相同也可以不同

### 规则：

​			1.被重载的方法可以改变返回类型；
​			2.被重载的方法可以改变访问修饰符；
​			3.被重载的方法可以声明新的或更广的检查异常；
​			4.方法能够在同一个类中或者在一个子类中被重载。
​			5.无法以返回值类型作为重载函数的区分标准。

## 注意：

​				方法重写时，子类方法的访问权限必须大于等于父类方法的访问权限



# 向上转型和向下转型

---

## 向上转型

### 概念：

​			父类引用指向子类对象

### 特性：

​			向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以**调用父类类型中的所有成			员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现**。



## 向下转型

### 概念：

​			子类对象指向父类引用

### 注意：

​			如果**父类引用对象指向的是子类对象**，那么在向下转型的过程中是安全的，也就是编译是不会出错误。
​			但是如果**父类引用对象是父类本身**，那么在向下转型的过程中是不安全的，编译不会出错，但是**运行时会出现我们			开始提到的 Java 强制类型转换异常**，一般使用 **instanceof** 运算符（**比较运行时类型，而不是静态类型**）来避免			出此类错误。



# 动态分派和静态分派

---

## 静态分派

### 特性：

​			静态分派只会涉及重载，而重载是在编译期间确定的，那么静态分派自然是一个静态的过程

​			静态分派的最直接的解释是**在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的**。

​			原因在于**静态类型的变化仅仅在使用时发生，变量本省的类型不会发生变化**。

### 理解:

​			由于只涉及重载，当一个方法需要传递参数时，只关注参数本身的静态类型，而不是它所指向的实际类型

### 示例：

​				B extend A，当一个方法的参数为B类的对象时，即使将B类进行向上转型，使A类引用指向B类对象，也不				能将该引用传递给该方法当参数，理解为只看静态类型。不过参数为A类型的对象时，可以将B类型的对象				当参数传递。

## 动态分派

一个最直接的例子就是方法重写



# 抽象类和接口区别



| **Java7的特性** |         抽象类         |                   接口                   |
| :-------------: | :--------------------: | :--------------------------------------: |
|    构造方法     |           ✓            |                    ✕                     |
|  普通成员变量   |           ✓            |                    ✕                     |
|    普通方法     |           ✓            |                    ✕                     |
|    访问类型     |     public,protect     |               public(默认)               |
|    静态方法     |           ✓            |  ✕（自Java8之后就可以有静态和默认方法）  |
|  静态成员变量   |           ✓            |      ✓（默认为public static final）      |
|    类的实现     |        继承一个        |                 实现多个                 |
|    使用方向     | 代码实现，可以重复使用 | 系统架构设计，用于定义模块之间的通信契约 |



| **Java8的特性** | 抽象类                 | 接口                                                         |
| --------------- | ---------------------- | ------------------------------------------------------------ |
| 构造方法        | ✓                      | ✕                                                            |
| 普通成员变量    | ✓                      | ✕                                                            |
| 普通方法        | ✓                      | ✕                                                            |
| 访问类型        | public,protect         | public(默认)                                                 |
| 静态方法        | ✓                      | ✓（可以有默认方法default修饰和静态方法<br />     【都可以有方法体】） |
| 静态成员变量    | ✓                      | ✓（默认为public static final）                               |
| 类的实现        | 继承一个               | 实现多个                                                     |
| 使用方向        | 代码实现，可以重复使用 | 系统架构设计，用于定义模块之间的通信契约                     |
| 继承其他同类型  | ✓                      | ✓                                                            |



# Object中的重要方法

## == 和 equals

---

### ==

#### 判断对象类型：

既可以是基本类型，也可以是引用类型

基本类型：判断值是否相等

引用类型：判断地址是否相同，即判断指向对象是否相同

#### 注意：当两个对象类型都不相同时，产生编译错误，



### equals

#### 判断对象类型

只能是引用类型

默认判断地址是否相等，一般可以子类重写判断内容是否相等。比如Integer，String



## hashocde方法

---

### 结论：

​			1.提高具有哈希结构的容器的效率

​			2.两个引用，如果指向的是同一个对象，则哈希值肯定是一样的

​			3.两个引用，如果指向的是不同对象，则哈希值是不一样的（在范围较大时，可能会产生碰撞）

​			4.哈希值主要是通过地址计算的，但不能完全等价

​			5.在集合中，如果有需要的话，也会重写

## finalize方法（新版Java已经弃用该方法）

---

### 对象回收：

​				当某个对象没有引用指向它时，系统就会认为该对象是一个垃圾，会使用垃圾回收机制来销毁该对象。
​				在销毁该对象前，会调用该方法。

### 调用时间：

​				当对象被回收时，系统自动调用finalize方法，子类可以重写该方法，进行资源释放操作

### 垃圾回收机制的调用：

​				由系统决定（系统有自己的GC算法），也可以通过System.gc（）来主动触发GC机制

### 注意：

​				在实际开发中，一般不会使用finalize方法（系统并不是时刻监控，一产生垃圾就回收），但是必须了解

# 用户自定义类

---

## 访问控制符

|      | 访问级别 | 访问控制修饰符 | 同类 | 同包   | 子类 | 不同包 |
| ---- | -------- | -------------- | ---- | ------ | ---- | ------ |
| 1    | 公开     | public         | 可以 | 可以   | 可以 | 可以   |
| 2    | 受保护   | protected      | 可以 | 可以   | 可以 | 不可以 |
| 3    | 默认     | 没有修饰符     | 可以 | 可以   | 没有 | 不可以 |
| 4    | 私有     | private        | 可以 | 不可以 | 没有 | 不可以 |

### 注意：

​			一般不用private修饰类



## final实例字段

### 特性：

​			用final关键字修饰字段的一旦在初始化完成后就不能再改变它的值

### 初始化：

​			用final声明的字段必须要在构造对象时完成初始化（在构造器执行完成时必须完成初始化）
​	——final字段初始化可以在
​												1.定义时
​												2.代码块
​												3.构造器
​			完成初始化

### 注意细节：

​			1.被final修饰的类不能被继承，其中的方法自然也不能被重写
​			2.被final修饰的方法只能被子类继承，不能被子类重写
​			3.被final修饰的类的属性或局部变量不能再修改它的值
​			4.被final修饰的方法可以进行重载，但是不能进行重写

## static实例字段

### 特性：

​			可以用于类的属性和方法上，被static修饰的方法属于类方法和类变量，可以由类名调用

### 初始化：

​			1.定义时
​			2.静态代码块
​			

### 注意：

​			1.不能在构造器中完成初始化
​			2.可以进行重载，重载是编译时多态
​			3.不能进行重写，重写时运行时多态

## 对象构造



### 默认字块初始化

​			在类中声明的字段当没有在构造器中显式地初始化时，就会被自动地赋为默认值。
​			数值为0，布尔类型为false，对象引用为null

### 			注意：

​					**方法中的局部变量**必须明确地初始化，但是在类中声明的字段没有初始化就会被赋为默认值。

### 初始化块

​			在一个类的声明中可以包含任意多个代码块，这些代码块可以在这些类的对象构造时执行

### 调用构造器的具体处理步骤

​			1.如果构造器的第一行调用另一个构造器，则根据提供的参数执行另一个构造器。
​			2.否则:
​						所有数据字段初始化为其默认值
​						按照在类声明中出现顺序，执行所有字段初始化方法和初始化块。
​			3.执行构造器主体代码

### 静态代码块

​			会在类第一次加载时执行，也只执行一次。后面不管声明多少对象，都不会再执行

### 静态字段初始化

​			可以使用一个静态的代码块初始化静态字段

## 抽象类

​			只能用来修饰类和方法

### 特点：

​			1.抽象类中不一定有抽象方法（也可以什么方法也没有）
​			2.有抽象方法一定是抽象类，要声明为abstract
​			3.抽象方法不能有方法体
​			4.抽象方法不能由private,final,static来修饰，因为这些关键字与重写相违背
​			5.可以对抽象方法进行重载，重写（主要）
​			**6.任何与抽象方法相违背的关键字都不能修饰抽象类和抽象方法**，如private,static,final
​			**7.抽象类可以有任意成员，但是不能实例化**
​			**8.一个类继承抽象类，则必须实现抽象类中所有抽象方法，否则也要声明为抽象类**

## 接口

### 继承与接口价值区别：

​			继承：解决代码复用性和可维护性

​			接口：通过【接口规范性和动态绑定机制】设计好各种规范，让其他类去实现这些方法，即更加灵活

### 特点（主要针对JDK 8）：

​			1.接口不能实例化
​			2.接口中的方法是由public  abstract修饰，可以直接简写为void  方法名（）
​			3.接口中属性都是由public static final 修饰的，属性声明可以简写为 ：数据类型 变量名
​			4.实现接口就必须将接口中所有抽象方法都实现
​			5.抽象类实现接口时，可以不实现抽象方法（觉得和抽象类中特点 8相似）
​			**6.一个类可以实现多个接口**
​			**7.接口不能继承其他类（抽象类也不行，试验过全部抽象方法的抽象类也不行），但是可以继承多个其他接口**
​			**8.接口的修饰符只能是public 和 default**（JDK 8后面的版本有）

### 接口多态：

​			使用接口类型传递参数可以对实现了该接口的类进行方法调用。**哪个实现接口的类对象传进来，使使用哪个实现**
​			**依然可以使用 instanceOf来判断运行类型**

### 接口多态传递：

​			interface A , interface B extends A , class M implements B
​			=>B b=new M()    A a=new M()

## 内部类：

### 		分类：

​			定义在外部类的局部位置上（如:方法中）
​					局部内部类（有类名）
​					匿名内部类（没有类名）

​			定义在外部类的成员位置上
​					成员内部类（不用static修饰）
​					静态内部类（用static修饰）

### 		类的五大成员：

​			属性、方法、构造器、代码块、内部类

### 		注意：

#### 			局部内部类：

​			**作用域：方法/代码块**

​				1.可以直接访问外部类所有成员
​				2.内部类不能用访问修饰符、static修饰（理解为一个局部变量，局部变量不能用访问修饰符，static修饰）
​					但是可以用final修饰
​				3.外部类访问局部内部类成员=》**在作用域中创建内部类对象**进行访问
​				**4.作用域在方法 / 代码块中**
​					a）如果局部内部类中有和外部类重名的方法，满足就近原则
​					b)  要访问外部类成员同名成员
​							外部类非静态成员：Outer . this . 成员名（this表示调用内部类所在方法的对象）
​							外部类静态成员：Outer . 成员名

#### 			匿名内部类：

​				**可以用来作为方法的参数传递**

##### 				针对接口的匿名内部类：

​					在实现接口时，有时并不想对临时只使用一次的情况专门定义一个实现类，
​					就可以在需要接口实现类的方法中定义一个匿名内部类。
​					
​					Interface  A{……}
​					
​					void method{
​						A  a = new A(这里不能有参数){
​							对A接口中抽象方法的实现（单纯只有抽象方法实现）
​						}
​					}

###### 							注意：

​							1.编译类型 A，运行类型 匿名内部类
​							2.系统会自动以  外部类名$数字 这样的方式对匿名内部类赋一个系统名称
​							3.匿名内部类只是单纯用来创建一个以接口实现类为模板的实例，并把地址返回给a。
​								**在实例创建完成后（使用一次），匿名内部类这个模板就不能再使用了**

##### 				针对类的匿名内部类：

​					理解为一种只想临时使用一次的对父类的继承，但凡继承可以用到的特性它都可以用到，
​					如：对父类方法的重写和定义自己独有的成员

​					class Father{}

​					void f1(){
​						Father f = new Father(构造器传参){
​							//定义自己独有成员
​							//重写父类方法
​						}
​						f . 成员方法（）； 
​					}

###### 					注意：

​					1.系统会自动给他一个系统名称和内部类命名方式相同
​					**2.括号内传递的参数是构造器传参，赋值给从父类继承来的成员变量**
​					（**用的是父类的构造器，不能自己定义构造器样式**）
​					**3.对抽象类来说，里面的抽象方法全部要实现**
​					**4.由于成员变量不遵循动态绑定机制，用父类引用调用的都是父类有的成员变量**
​						**但是可以定义自己的成员变量，然后通过方法获取这些变量的值**									
