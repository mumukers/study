# 包

---

## 注意

​			当引入一个包时，只允许访问该目录下的所有类，而不允许访问子目录下的类（除非单独引入）

​			解释：该子目录下可能**有相同的类名导致冲突**

# 基本类型的自动装箱和拆箱

---

## 适用位置

​				引用类型和值类型之间

## 装箱

​			把基础类型封装为一个类

### 			具体实现：

​							调用包装器的**valueOf**方法实现。

## 拆箱

​			把类转化为基础类型（把引用类型的对象转化为值类型的对象）

### 			具体实现：

​							调用包装器的**xxValue**方法实现。

## 注意

​			1.在通过valueOf创建**Integer对象**（这里Integer与Double，Boolean不同）时，如果值在[-128,127]之间，返回指				向IntegerCache.cache中已经存在对象的引用。

​			2.在装箱时，对valueOf来说，返回指向不同对象的引用时，Double比Integer的范围要大一些

​			3.Boolean可以直接判断内容是否相等

​			4.当包装类和它对应的值类型比较时，包装类自动拆箱，==比较的是数值

​			

# 控制流程

---

## for循环的执行顺序

​			for（表达式1；表达式2；表达式3）{
​					循环体；
​			}

​			第一步：循环开始执行一次表达式1（表达式1只在循环开始时执行，剩下的循环都从第二步判断开始）
​			第二步：执行表达式2进行判断
​			第三步：进入循环**执行循环体**
​			第四步：执行表达式3进行迭代

# 方法参数

---

## 如何传递参数？

​			Java中使用创建对象引用的副本来传递参数。

## Java对方法参数能做什么和不能做什么？

​			1.方法不能修改基本数据类型的参数
​			2.方法可以修改对象参数的状态。
​			3.方法不能让对象参数引用一个新对象

# 方法重载与方法重写

---



## 方法重写

### 概念:

​			重写是**子类对父类的<u>*允许访问的方法*</u>的实现过程进行重新编写**, 返回值和形参都不能改变。
​			即外壳不变，核心重写！（必须是父类中有的方法）

### 规则：

​			1.重写的方法的访问权限不能比父类中被重写的方法的访问权限低，也就是private的方法不能被重写
​			2.参数列表，返回值，方法名必须完全相同
​			3.声明为**final**的方法不能被重写。声明为**static**的方法不能被重写，但是能再次声明
​			4.重写的方法能够抛出任何非强制性异常，但不能抛出**新的强制性异常**
​			5.对于不能继承的方法，就不能重写该方法

### 运行时：

​			先找到两个类中都有的方法，然后执行时看子类的具体实现

## 方法重载

### 概念：

​			重载是在一个类里面，方法名相同，参数不同，返回值可以相同也可以不同

### 规则：

​			1.被重载的方法可以改变返回类型；
​			2.被重载的方法可以改变访问修饰符；
​			3.被重载的方法可以声明新的或更广的检查异常；
​			4.方法能够在同一个类中或者在一个子类中被重载。
​			5.无法以返回值类型作为重载函数的区分标准。

## 注意：

​				方法重写时，子类方法的访问权限必须大于等于父类方法的访问权限



# 向上转型和向下转型

---

## 向上转型

### 概念：

​			父类引用指向子类对象

### 特性：

​			向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以**调用父类类型中的所有成			员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现**。



## 向下转型

### 概念：

​			子类对象指向父类引用

### 注意：

​			如果**父类引用对象指向的是子类对象**，那么在向下转型的过程中是安全的，也就是编译是不会出错误。
​			但是如果**父类引用对象是父类本身**，那么在向下转型的过程中是不安全的，编译不会出错，但是**运行时会出现我们			开始提到的 Java 强制类型转换异常**，一般使用 **instanceof** 运算符（**比较运行时类型，而不是静态类型**）来避免			出此类错误。



# 动态分派和静态分派

---

## 静态分派

### 特性：

​			静态分派只会涉及重载，而重载是在编译期间确定的，那么静态分派自然是一个静态的过程

​			静态分派的最直接的解释是**在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的**。

​			原因在于**静态类型的变化仅仅在使用时发生，变量本省的类型不会发生变化**。

### 理解:

​			由于只涉及重载，当一个方法需要传递参数时，只关注参数本身的静态类型，而不是它所指向的实际类型

### 示例：

​				B extend A，当一个方法的参数为B类的对象时，即使将B类进行向上转型，使A类引用指向B类对象，也不				能将该引用传递给该方法当参数，理解为只看静态类型。不过参数为A类型的对象时，可以将B类型的对象				当参数传递。

## 动态分派

一个最直接的例子就是方法重写



# 抽象类和接口区别



| **Java7的特性** |         抽象类         |                   接口                   |
| :-------------: | :--------------------: | :--------------------------------------: |
|    构造方法     |           ✓            |                    ✕                     |
|  普通成员变量   |           ✓            |                    ✕                     |
|    普通方法     |           ✓            |                    ✕                     |
|    访问类型     |     public,protect     |               public(默认)               |
|    静态方法     |           ✓            |  ✕（自Java8之后就可以有静态和默认方法）  |
|  静态成员变量   |           ✓            |      ✓（默认为public static final）      |
|    类的实现     |        继承一个        |                 实现多个                 |
|    使用方向     | 代码实现，可以重复使用 | 系统架构设计，用于定义模块之间的通信契约 |



| **Java8的特性** | 抽象类                 | 接口                                                         |
| --------------- | ---------------------- | ------------------------------------------------------------ |
| 构造方法        | ✓                      | ✕                                                            |
| 普通成员变量    | ✓                      | ✕                                                            |
| 普通方法        | ✓                      | ✕                                                            |
| 访问类型        | public,protect         | public(默认)                                                 |
| 静态方法        | ✓                      | ✓（可以有默认方法default修饰和静态方法<br />     【都可以有方法体】） |
| 静态成员变量    | ✓                      | ✓（默认为public static final）                               |
| 类的实现        | 继承一个               | 实现多个                                                     |
| 使用方向        | 代码实现，可以重复使用 | 系统架构设计，用于定义模块之间的通信契约                     |
| 继承其他同类型  | ✓                      | ✓                                                            |



# Object中的重要方法

## == 和 equals

---

### ==

#### 判断对象类型：

既可以是基本类型，也可以是引用类型

基本类型：判断值是否相等

引用类型：判断地址是否相同，即判断指向对象是否相同

#### 注意：当两个对象类型都不相同时，产生编译错误，



### equals

#### 判断对象类型

只能是引用类型

默认判断地址是否相等，一般可以子类重写判断内容是否相等。比如Integer，String



## hashocde方法

---

### 结论：

​			1.提高具有哈希结构的容器的效率

​			2.两个引用，如果指向的是同一个对象，则哈希值肯定是一样的

​			3.两个引用，如果指向的是不同对象，则哈希值是不一样的（在范围较大时，可能会产生碰撞）

​			4.哈希值主要是通过地址计算的，但不能完全等价

​			5.在集合中，如果有需要的话，也会重写

## finalize方法（新版Java已经弃用该方法）

---

### 对象回收：

​				当某个对象没有引用指向它时，系统就会认为该对象是一个垃圾，会使用垃圾回收机制来销毁该对象。
​				在销毁该对象前，会调用该方法。

### 调用时间：

​				当对象被回收时，系统自动调用finalize方法，子类可以重写该方法，进行资源释放操作

### 垃圾回收机制的调用：

​				由系统决定（系统有自己的GC算法），也可以通过System.gc（）来主动触发GC机制

### 注意：

​				在实际开发中，一般不会使用finalize方法（系统并不是时刻监控，一产生垃圾就回收），但是必须了解



# 面向对象三大特性

---

## 封装

​			把抽象出来的数据【属性】和对数据的操作【方法】封装到一起。数据被保护在内部，程序的其他部分只有通过被			授权的操作【方法】才能对数据进行操作。

### 			好处：

​			1.隐藏实现细节
​			2.可以对数据进行验证

## 继承

​			解决代码复用性问题，当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的			属性和方法，其他类不需要再声明这些属性和方法，只需要通过extends声明继承父类即可。

### 		好处：

​				1.代码复用性提高了
​				2.代码扩展性和可维护性提高了

### 		本质：

​				当继承关系确定后，子类对象创建时，建立的是一个查找的关系

### 		细节：

​				1.子类继承了父类所有属性和方法，非私有的属性和方法子类可以直接访问，私有的属性和方法只能通过父类提					供的公有方法访问
​				2.子类没有继承父类构造器，但是必须调用父类构造器，完成父类初始化。
​				3.当创建子类对象时，关键字不管使用哪个子类构造器默认总会调用父类构造器。如果父类中没有提供无参构造					器，则必须要通过**super**关键字指定用父类中哪个构造器。
​				4.可以用**super**关键字显式指定使用父类中哪个构造器。
​				**5**.super在使用时只能放在构造器第一行，super只能在构造器中使用。
​				**6**.super（）和this（）都只能在构造器第一行，所以不能同时存在。
​				**7**.super（）父类构造器的调用不只限于直接父类，可以一直上溯到Object类
​				8.Java只支持单继承。要继承两个，就要串起来。
​				9.不能滥用继承

## 多态

​			方法和对象具有多种形态，是面向对象的第三大特性，是建立在封装和继承的基础上的

### 			多态具体实现：

#### 					方法多态：

​							方法重载和方法重写

#### 					对象多态：

​							1.对象的编译类型和运行类型可以不同，编译类型是在定义时就确定了，不能变化
​							2.对象的运行类型是可以变化的，可以通过getClass（）方法获取查看
​							3.编译类型看等号左边，运行类型看等号右边

### 					Java的动态绑定机制：

​							1.当调用对象方法时，该方法和对象内存地址/运行类型绑定
​							2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用
​								示例：B继承A，A a=new B()，调用a对象中的属性时，是调用A类中的而不是B类中的

# 用户自定义类

---

## 访问控制符

|      | 访问级别 | 访问控制修饰符 | 同类 | 同包   | 子类 | 不同包 |
| ---- | -------- | -------------- | ---- | ------ | ---- | ------ |
| 1    | 公开     | public         | 可以 | 可以   | 可以 | 可以   |
| 2    | 受保护   | protected      | 可以 | 可以   | 可以 | 不可以 |
| 3    | 默认     | 没有修饰符     | 可以 | 可以   | 没有 | 不可以 |
| 4    | 私有     | private        | 可以 | 不可以 | 没有 | 不可以 |

### 注意：

​			一般不用private修饰类



## final实例字段

### 特性：

​			用final关键字修饰字段的一旦在初始化完成后就不能再改变它的值

### 注意：

​			用final声明的字段必须要在构造对象时完成初始化（在构造器执行完成时必须完成初始化）



## 对象构造



### 默认字块初始化

​			在类中声明的字段当没有在构造器中显式地初始化时，就会被自动地赋为默认值。
​			数值为0，布尔类型为false，对象引用为null

### 			注意：

​					**方法中的局部变量**必须明确地初始化，但是在类中声明的字段没有初始化就会被赋为默认值。

### 初始化块

​			在一个类的声明中可以包含任意多个代码块，这些代码块可以在这些类的对象构造时执行

### 调用构造器的具体处理步骤

​			1.如果构造器的第一行调用另一个构造器，则根据提供的参数执行另一个构造器。
​			2.否则:
​						所有数据字段初始化为其默认值
​						按照在类声明中出现顺序，执行所有字段初始化方法和初始化块。
​			3.执行构造器主体代码

### 静态代码块

​			会在类第一次加载时执行，也只执行一次。后面不管声明多少对象，都不会再执行

### 静态字段初始化

​			可以使用一个静态的代码块初始化静态字段
