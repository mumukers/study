# 方法重载与方法重写

---



## 方法重写

### 概念:

​			重写是**子类对父类的<u>*允许访问的方法*</u>的实现过程进行重新编写**, 返回值和形参都不能改变。
​			即外壳不变，核心重写！（必须是父类中有的方法）

### 规则：

​			1.重写的方法的访问权限不能比父类中被重写的方法的访问权限低，也就是private的方法不能被重写
​			2.参数列表，返回值，方法名必须完全相同
​			3.声明为**final**的方法不能被重写。声明为**static**的方法不能被重写，但是能再次声明
​			4.重写的方法能够抛出任何非强制性异常，但不能抛出**新的强制性异常**
​			5.对于不能继承的方法，就不能重写该方法

### 运行时：

​			先找到两个类中都有的方法，然后执行时看子类的具体实现

## 方法重载

### 概念：

​			重载是在一个类里面，方法名相同，参数不同，返回值可以相同也可以不同

### 规则：

​			1.被重载的方法可以改变返回类型；
​			2.被重载的方法可以改变访问修饰符；
​			3.被重载的方法可以声明新的或更广的检查异常；
​			4.方法能够在同一个类中或者在一个子类中被重载。
​			5.无法以返回值类型作为重载函数的区分标准。



# 向上转型和向下转型

---

## 向上转型

### 概念：

​			父类引用指向子类对象

### 特性：

​			向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以**调用父类类型中的所有成			员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现**。



## 向下转型

### 概念：

​			子类对象指向父类引用

### 注意：

​			如果**父类引用对象指向的是子类对象**，那么在向下转型的过程中是安全的，也就是编译是不会出错误。
​			但是如果**父类引用对象是父类本身**，那么在向下转型的过程中是不安全的，编译不会出错，但是**运行时会出现我们			开始提到的 Java 强制类型转换异常**，一般使用 **instanceof** 运算符（**比较运行时类型，而不是静态类型**）来避免			出此类错误。



# 动态分派和静态分派

---

## 静态分派

### 特性：

​			静态分派只会涉及重载，而重载是在编译期间确定的，那么静态分派自然是一个静态的过程

​			静态分派的最直接的解释是**在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的**。

​			原因在于**静态类型的变化仅仅在使用时发生，变量本省的类型不会发生变化**。

### 理解:

​			由于只涉及重载，当一个方法需要传递参数时，只关注参数本身的静态类型，而不是它所指向的实际类型

### 示例：

​				B extend A，当一个方法的参数为B类的对象时，即使将B类进行向上转型，使A类引用指向B类对象，也不				能将该引用传递给该方法当参数，理解为只看静态类型。不过参数为A类型的对象时，可以将B类型的对象				当参数传递。

## 动态分派

一个最直接的例子就是方法重写



# Object中的重要方法

## == 和 equals

---

### ==

#### 判断对象类型：

既可以是基本类型，也可以是引用类型

基本类型：判断值是否相等

引用类型：判断地址是否相同，即判断指向对象是否相同

#### 注意：当两个对象类型都不相同时，产生编译错误，



### equals

#### 判断对象类型

只能是引用类型

默认判断地址是否相等，一般可以子类重写判断内容是否相等。比如Integer，String



## hashocde方法

---

### 结论：

​			1.提高具有哈希结构的容器的效率

​			2.两个引用，如果指向的是同一个对象，则哈希值肯定是一样的

​			3.两个引用，如果指向的是不同对象，则哈希值是不一样的（在范围较大时，可能会产生碰撞）

​			4.哈希值主要是通过地址计算的，但不能完全等价

​			5.在集合中，如果有需要的话，也会重写

## finalize方法（新版Java已经弃用该方法）

---

### 对象回收：

​				当某个对象没有引用指向它时，系统就会认为该对象是一个垃圾，会使用垃圾回收机制来销毁该对象。
​				在销毁该对象前，会调用该方法。

### 调用时间：

​				当对象被回收时，系统自动调用finalize方法，子类可以重写该方法，进行资源释放操作

### 垃圾回收机制的调用：

​				由系统决定（系统有自己的GC算法），也可以通过System.gc（）来主动触发GC机制

### 注意：

​				在实际开发中，一般不会使用finalize方法（系统并不是时刻监控，一产生垃圾就回收），但是必须了解



# 面向对象三大特性

---

## 封装

​			把抽象出来的数据【属性】和对数据的操作【方法】封装到一起。数据被保护在内部，程序的其他部分只有通过被			授权的操作【方法】才能对数据进行操作。

### 			好处：

​			1.隐藏实现细节
​			2.可以对数据进行验证

## 继承

​			解决代码复用性问题，当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的			属性和方法，其他类不需要再声明这些属性和方法，只需要通过extends声明继承父类即可。

### 		好处：

​				1.代码复用性提高了
​				2.代码扩展性和可维护性提高了

### 		本质：

​				当继承关系确定后，子类对象创建时，建立的是一个查找的关系

### 		细节：

​				1.子类继承了父类所有属性和方法，非私有的属性和方法子类可以直接访问，私有的属性和方法只能通过父类提					供的公有方法访问
​				2.子类没有继承父类构造器，但是必须调用父类构造器，完成父类初始化。
​				3.当创建子类对象时，关键字不管使用哪个子类构造器默认总会调用父类构造器。如果父类中没有提供无参构造					器，则必须要通过**super**关键字指定用父类中哪个构造器。
​				4.可以用**super**关键字显式指定使用父类中哪个构造器。
​				**5**.super在使用时只能放在构造器第一行，super只能在构造器中使用。
​				**6**.super（）和this（）都只能在构造器第一行，所以不能同时存在。
​				**7**.super（）父类构造器的调用不只限于直接父类，可以一直上溯到Object类
​				8.Java只支持单继承。要继承两个，就要串起来。
​				9.不能滥用继承

## 多态

​			方法和对象具有多种形态，是面向对象的第三大特性，是建立在封装和继承的基础上的

### 			多态具体实现：

#### 					方法多态：

​							方法重载和方法重写

#### 					对象多态：

​							1.对象的编译类型和运行类型可以不同，编译类型是在定义时就确定了，不能变化
​							2.对象的运行类型是可以变化的，可以通过getClass（）方法获取查看
​							3.编译类型看等号左边，运行类型看等号右边

### 					Java的动态绑定机制：

​							1.当调用对象方法时，该方法和对象内存地址/运行类型绑定
​							2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用
​								示例：B继承A，A a=new B()，调用a对象中的属性时，是调用A类中的而不是B类中的

# 访问控制符

---



|      | 访问级别 | 访问控制修饰符 | 同类 | 同包   | 子类 | 不同包 |
| ---- | -------- | -------------- | ---- | ------ | ---- | ------ |
| 1    | 公开     | public         | 可以 | 可以   | 可以 | 可以   |
| 2    | 受保护   | protected      | 可以 | 可以   | 可以 | 不可以 |
| 3    | 默认     | 没有修饰符     | 可以 | 可以   | 没有 | 不可以 |
| 4    | 私有     | private        | 可以 | 不可以 | 没有 | 不可以 |

## 注意：

​			一般不用private修饰类
